# К Principios de Polimorfismo Aplicados

Este documento describe c贸mo se implement贸 el polimorfismo (sobrecarga y sobrescritura) en las clases de Empleado de la Agencia de Viajes.

---

## 1. Sobrecarga (Overloading)

La sobrecarga se implement贸 en la clase de gesti贸n central, `AgenciaViajes`, para proporcionar m煤ltiples formas de realizar una b煤squeda utilizando un 煤nico nombre de m茅todo, lo que mejora la usabilidad y la claridad de la interfaz.

* **Clase Aplicada:** `AgenciaViajes`

* **M茅todos Sobrecargados:**

    ```java
    // 1. Buscar por c贸digo 煤nico de reserva (String)
    public Reserva buscarReserva(String codigo) 
    
    // 2. Buscar por el objeto Cliente asociado (Cliente)
    public ArrayList<Reserva> buscarReserva(Cliente cliente)
    
    // 3. Buscar por un rango de fechas (LocalDate, LocalDate)
    public ArrayList<Reserva> buscarReserva(LocalDate inicio, LocalDate fin) 
    ```

* **Justificaci贸n:**
    Es fundamental que el sistema de la agencia permita la recuperaci贸n de reservas utilizando **diferentes criterios** (identificador 煤nico, cliente, o periodo de tiempo). La sobrecarga permite que todas estas operaciones se agrupen l贸gicamente bajo el mismo nombre (`buscarReserva`), simplificando la interfaz para el desarrollador.

---

## 2. Sobrescritura (Overriding)

La sobrescritura se utiliza para que las subclases (`EmpleadoPlanta` y `EmpleadoContrato`) proporcionen implementaciones espec铆ficas de los m茅todos definidos en la clase padre (`Empleado`), asegurando que cada tipo de empleado tenga su propia l贸gica de c谩lculo salarial y descripci贸n.

* **Clases Aplicadas:** `EmpleadoPlanta` y `EmpleadoContrato`

* **M茅todos Sobrescritos con `@Override`:**

    | M茅todo | Clase Padre (`Empleado`) | Subclase 1 (`EmpleadoPlanta`) | Subclase 2 (`EmpleadoContrato`) |
    | :--- | :--- | :--- | :--- |
    | `calcularSalario()` | `return salarioBase` | `return salarioBase + bono` (5% por a帽o de antig眉edad) | `return salarioBase` (Solo salario base) |
    | `obtenerDescripcion()` | Retorna nombre e identificaci贸n | Retorna nombre, identificaci贸n **y a帽os de antig眉edad** | Retorna nombre, identificaci贸n **y fecha de fin de contrato** |

---

## 3. Polimorfismo Din谩mico (Dynamic Binding)

El polimorfismo din谩mico es la capacidad de que la m谩quina virtual de Java (JVM) determine en tiempo de ejecuci贸n (runtime) qu茅 implementaci贸n de un m茅todo sobrescrito debe ejecutarse, bas谩ndose en el **tipo real** del objeto, no en el tipo de su referencia.

* **Ejemplo de C贸digo Demostrado:**

    ```java
    ArrayList<Empleado> personal = new ArrayList<>();
    personal.add(new EmpleadoPlanta(...));    // Tipo real: EmpleadoPlanta
    personal.add(new EmpleadoContrato(...)); // Tipo real: EmpleadoContrato

    for (Empleado e : personal) {
        // Aunque 'e' es de tipo Empleado, la JVM llama a la versi贸n correcta.
        // Si es Planta, llama al calcularSalario con bono.
        // Si es Contrato, llama al calcularSalario simple.
        System.out.println("Salario: $" + e.calcularSalario()); 
    }
    ```

* **Explicaci贸n:**
    La clase `AgenciaViajes` utiliza un **ArrayList polim贸rfico** (`ArrayList<Empleado>`) que almacena objetos de diferentes subclases. Al iterar y llamar a `e.calcularSalario()`, el m茅todo concreto que se ejecuta no se conoce en tiempo de compilaci贸n. El *dynamic binding* asegura que, para cada elemento de la colecci贸n, se ejecute la l贸gica de salario definida en su clase espec铆fica (`EmpleadoPlanta` o `EmpleadoContrato`).

---

## 4. Beneficios del Polimorfismo

| Beneficio | Descripci贸n |
| :--- | :--- |
| **Extensibilidad** | Permite a帽adir nuevos tipos de empleados (ej. `EmpleadoFreelance`) simplemente creando una nueva subclase y sobrescribiendo los m茅todos. El c贸digo de gesti贸n de n贸mina (`procesarNominaCompleta`) no necesita ser modificado. |
| **C贸digo Limpio** | Se evita el uso de m煤ltiples sentencias `if`/`else if` o `switch` para determinar el tipo de objeto y ejecutar la l贸gica correcta. Se utiliza una 煤nica interfaz (`Empleado`) para trabajar con m煤ltiples implementaciones. |
| **Mantenibilidad** | Los cambios en la l贸gica de c谩lculo salarial de un tipo de empleado (ej. aumentar el bono de `EmpleadoPlanta`) se encapsulan solo en esa subclase, sin afectar otras clases de empleados o el sistema de n贸mina principal. |

| 驴Qu茅 ser铆a dif铆cil sin polimorfismo? |
| :--- |
| La clase `AgenciaViajes` se volver铆a muy r铆gida y tendr铆a que conocer y manejar expl铆citamente cada subclase de empleado, oblig谩ndonos a escribir m茅todos espec铆ficos para cada una o a usar l贸gica de verificaci贸n de tipos (`instanceof`), lo cual va en contra del dise帽o orientado a objetos. |